\section{Taxi queue management}
The algorithm is run every time there is a new event which changes the order or the number of the elements in one of the system queues.

According to the type of event, the algorithm updates the queues moving, deleting or creating elements. There are several types of events:
\begin{enumerate}
	\item New request incomes \label{event:new_req}
	\item Taxi Driver accepts a request \label{event:accepted_req}
	\item Taxi Driver refuses a request \label{event:refuses_req}
	\item Taxi Driver changes zone \label{event:changed_zone}
	\item Taxi Driver changes his/her status \label{event:changed_status}
\end{enumerate}
The input data are:
\begin{itemize}
	\item $Q_i$: list of FIFO queues, where $i$ is the zone of the correspondent queue. 
	\item $e$: event which will change the queues.
	\item $OOS$: list of taxi drivers out of service.
	\item $B$: list of busy taxi drivers.
	\item $P$: list of taxi drivers with a pending ride.
\end{itemize}  

The algorithm works differently accordingly with the input event. The alternatives are explained in the following subsections.

\subsection{Type \ref{event:new_req}, new request incomes}
The algorithm extracts the zone $z$ of the new incoming request, pops the first element of the $Q_z$ and inserts this element in $P$ list.

\subsection{Type \ref{event:accepted_req}, taxi driver accepts a request}
The algorithm extracts the taxi driver $t$ from the event and removes him/her from $P$. After that it inserts $t$ into $B$.

\subsection{Type \ref{event:refuses_req}, taxi driver refuses a request}
The algorithm extracts the taxi driver $t$ from the event and it removes him/her from $P$. After that it retrieves the taxi driver's actual zone $z$ and it pushes $t$ in $Q_z$.

\subsection{Type \ref{event:changed_zone}, taxi driver changes zone}
The algorithm extracts the taxi driver $t$, the previous zone $pz$ and the next zone $nz$ from the event and removes $t$ from $Q_{pz}$ and pushes $t$ into $Q_{nz}$.

\subsection{Type \ref{event:changed_status}, taxi driver changes status}
If the taxi driver $t$ changes his/her status from “not in service” to “in service”, the algorithm extracts the zone $z$ from the event, it removes $t$ from $OOS$ and pushes $t$ into $Q_z$.

If the taxi driver $t$ changes his/her status from “in service” to “not in service”, the algorithm extracts the zone $z$ from the event, it removes $t$ from $Q_z$ and pushes $t$ into $OOS$.


\section{Taxi sharing matching}
The algorithm is run by the back-end when a new shared ride is requested and it computes the compatible shared rides with the new one.

A ride can be compatible with a new one if its starting point is not further than $MaxBeginDistance$. $MaxBeginDistance$ is the variable which contains the value expressed in meters of the max accepted distance between the actual position of the passenger of a new ride and the starting point of another ride.

Furthermore the eventual new passenger needs to have the time to reach the starting point.

The last requirement, in order to be a compatible ride, is that once the rides are matched, the estimated travel time of the two rides does not increase of $ExtraPercentage$ of the previous estimated travel time, where $ExtraPercentage$ is the variable which contains the percentage of the max admissible increasing.

The input data:
\begin{itemize}
	\item $MaxBeginDistance$: is the max distance which the passenger has to walk in order to reach the starting point of the shared ride.
	\item $ExtraPercentage$: is the max increase of time travel for every ride, expressed in percentage.
	\item $SR$: is the set containing only the shared rides not started yet.
	\item $r$: is the new ride.
	\item $wv$: is the feasible walking speed of a person.
	\item $currentTime$: is the current time of the system.
\end{itemize}

Let $cr_i$ be an element of $SR$. $cr_i.startingPoint$ is the position of the beginning of the ride, $cr_i.duration$ is the estimated time needed for the ride and $cr_i.startingTime$ is the starting time of the ride.

A new ride, formed by two matched rides $cr_1$ and $cr_2$ is denoted by $ cr_1 \star cr_2 $. The starting point of the matched rides is the starting point of the first allocated ride, and the duration of the matched rides is computed from the starting point to the destination of the last passenger which will get off the taxi. $ (cr_1 \star cr_2).startingTime $ is equal to $cr_1.startingTime$.

A ride $cr_i$ is compatible if it fulfills every following condition:
\begin{itemize}
	\item $| cr_i.startingPoint - r.startingPoint | \leq MaxBeginDistance$
	\item $(cr_i \star r).duration  \leq cr_i.duration( 1+ ExtraPercentage)$
	\item $(cr_i \star r).duration  \leq r.duration( 1+ ExtraPercentage)$
	\item $ | cr_i.startingPoint - r.startingPoint | wv +currentTime \leq cr_i.startingTime$
\end{itemize}


\section{Taxi fee splitting}
This algorithm is run by the back-end in the case of shared rides to compute the percentages of the taxi fee that each passenger has to pay.

The algorithm computes the fee percentages proportionally to the overall distance traveled by all the people (travellers) that each passenger on the taxi brings with himself.

The input data are:
\begin{itemize}
    \item $P$: list of passengers;
    \item $T_i$: list of travellers associated with passenger $i$;
    \item $d(t)$: distance traveled by traveler $t$.
\end{itemize}

The algorithm computes $f_i$, that is the percentage of the fee that the passenger $i$ has to pay.
$f_i$ is expressed as a decimal number, i.e. $0 \le f_i \le 1$.

The algorithm works as follows:

\begin{equation}
    f_i = \dfrac
        {\displaystyle \sum_{t \in T_i} d(t)}
        {\displaystyle \sum_{p \in P} \sum_{t \in T_p} d(t)}
\end{equation}

An example of an application of this algorithm is shown in~\autoref{fee-splitting-ex}.

\begin{table}
\begin{center}
\begin{tabular}{ l  l  l  l  l }
    \hline
    \textbf{Passenger} & \textbf{Traveler} & \multicolumn{2}{c}{\textbf{Distance}} & \textbf{Fee} \\
    \hline
    \multirow{3}{*}{Alice} & 1 & 90 & \multirow{3}{*}{115} & \multirow{3}{*}{64\%} \\
    & 2 & 20 & & \\
    & 3 & 5 & & \\
    \hline
    \multirow{3}{*}{Bob} & 1 & 25 & \multirow{3}{*}{65} & \multirow{3}{*}{36\%} \\
    & 2 & 30 & & \\
    & 3 & 10 & & \\
    \hline
    \textbf{Total} & & \textbf{180} & \textbf{180} & \textbf{100\%} \\
    \hline
\end{tabular}
\caption{An example of the taxi fee splitting algorithm.}
\label{fee-splitting-ex}
\end{center}
\end{table}

\section{Taxi waiting calculation}
%TODO Eleonora
